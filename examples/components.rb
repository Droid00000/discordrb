# frozen_string_literal: true

require 'discordrb'

bot = Discordrb::Bot.new(token: ENV.fetch('BOT_TOKEN', nil), intents: [:servers])

# This is a fairly pointless example command. This only has to be registered once, so I reccomend commenting out
# the following three lines once you've registered it at least once.
bot.register_application_command(:components, 'New Components!', server_id: ENV.fetch('COMMAND_SERVER_ID', nil)) do |option|
  option.boolean('color', 'Whether the container should include an accent color.', required: false)
end

bot.application_command(:components) do |event|
  # Here, we fetch the emojis hash from the event's
  # server object. we then call all #values to convert
  # the hash into an array of its values (emojis). We can
  # then map each emoji into a string into the format of
  # mention, name and a random number between 1 and 500.
  # We then assign the resulting array of strings
  # into a variable called emojis.
  emojis = event.server.emojis.values.map do |emoji|
    "#{emoji.mention} â€” #{emoji.name} **(#{rand(1..500)})**\n"
  end

  # The `new_components` argument must be manually
  # set to true to use V2 components. Additionally,
  # it disables the content and embeds fields.
  event.respond(new_components: true) do |_, view|
    # Here we create a new container to contain all of our
    # other components. We don't have to do this, as all components
    # besides buttons and select menus can be used as top level
    # components, but for demonstration purposes, everything's in a container.
    # Most components take an optional ID parameter. If this is not provided
    # it will be automatically generated by Discord. Do keep in mind that an ID
    # can only be 32-bits. This means that snowflakes cannot be used as IDs.
    view.container(id: 1000) do |container|
      # A section must contain either a thumbnail or a button. This is currently the
      # only case where a button can be used without nesting it an action row.
      container.section do |section|
        section.thumbnail(media: event.server.icon_url)
        section.text_display(text: "### Emoji Statistics for #{event.server.name}")
        section.text_display(text: 'These are the current fake emoji stats for your server.')
      end

      # Conditionally set the accent color of the container to the user's
      # highest role color. This defaults to no accent color if not set.
      container.color = event.user.color if data.options['color']

      # This is a sperator we add to our container here.
      # In the UI this appears as a thin, translucent, grey
      # line when setting the divider option to true. Otherwise
      # the seperator can function as an invisible barrier of sorts.
      container.seperator(divider: true, spacing: :small)

      # We add a text display component to our container here.
      # A text display container is a container for text. When
      # using the new components system, the `content` field is
      # disabled, instead we can use a text display instead to emulate content.
      container.text_display(text: emojis.empty? ? 'No Emojis!' : emojis.take(10).join)

      # We add another seperator within our container here.
      # The spacing can be set to `:large` as well to
      # have a bigger gap between other components.
      container.seperator(divider: true, spacing: :small)

      # We clear the existing emojis array and append
      # a random emoji to array we just cleared.
      emojis.clear && 3.times { emojis << event.server.emojis.values.sample }

      # Here we create an action row inside of our container to add a select menu.
      # select menus and buttons, still have to be nested within an action row, with
      # one exception, but this can change in the future.
      container.row do |row|
        row.select_menu(custom_id: 'emojis', placeholder: 'Pick a statistic type...', min_values: 1) do |options|
          options.option(label: 'Reaction', value: 'Reaction', description: 'View reaction statistics.', emoji: emojis.sample)
          options.option(label: 'Message', value: 'Message', description: 'View message statistics.', emoji: emojis.sample)
          options.option(label: 'Lowest', value: 'Lowest', description: 'View the boring emojis.', emoji: emojis.sample)
        end
      end
    end
  end
end

# This doesn't actually display any stats, but returns a dummy message instead.
bot.select_menu(custom_id: 'emojis') do |event|
  case event.values.first
  when 'Reaction', 'Message'
    event.respond("You're viewing stats for #{event.values.first}s!")
  when 'Lowest'
    event.respond("You're viewing very boring stats!")
  else
    event.respond('What kind of stats...')
  end
end

bot.run
